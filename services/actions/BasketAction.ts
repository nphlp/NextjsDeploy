"use server";

import BasketService from "@class/BasketClass";
// import { requiresSafeMessage } from "@permissions/requiresSafeMessage";
import { Prisma } from "@prisma/client/client";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/client";

/**
 * # Basket Action Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `solid/solid-generator.ts`
 * - which uses `solid/templates/services/actions/{{model}}Action.hbs` as base template
 * - to generate server actions files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Create
type BasketCreateProps<T extends Prisma.BasketCreateArgs> = Prisma.SelectSubset<T, Prisma.BasketCreateArgs>;
type BasketCreateResponse<T extends Prisma.BasketCreateArgs> = GetResult<
    Prisma.$BasketPayload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

// Upsert
type BasketUpsertProps<T extends Prisma.BasketUpsertArgs> = Prisma.SelectSubset<T, Prisma.BasketUpsertArgs>;
type BasketUpsertResponse<T extends Prisma.BasketUpsertArgs> = GetResult<
    Prisma.$BasketPayload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

// Update
type BasketUpdateProps<T extends Prisma.BasketUpdateArgs> = Prisma.SelectSubset<T, Prisma.BasketUpdateArgs>;
type BasketUpdateResponse<T extends Prisma.BasketUpdateArgs> = GetResult<
    Prisma.$BasketPayload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

// Delete
type BasketDeleteProps<T extends Prisma.BasketDeleteArgs> = Prisma.SelectSubset<T, Prisma.BasketDeleteArgs>;
type BasketDeleteResponse<T extends Prisma.BasketDeleteArgs> = GetResult<
    Prisma.$BasketPayload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

// Create Many
type BasketCreateManyProps<T extends Prisma.BasketCreateManyArgs> = Prisma.SelectSubset<T, Prisma.BasketCreateManyArgs>;
type BasketCreateManyResponse = Prisma.BatchPayload;

// Update Many
type BasketUpdateManyProps<T extends Prisma.BasketUpdateManyArgs> = Prisma.SelectSubset<T, Prisma.BasketUpdateManyArgs>;
type BasketUpdateManyResponse = Prisma.BatchPayload;

// Delete Many
type BasketDeleteManyProps<T extends Prisma.BasketDeleteManyArgs> = Prisma.SelectSubset<T, Prisma.BasketDeleteManyArgs>;
type BasketDeleteManyResponse = Prisma.BatchPayload;

// Find First
type BasketFindFirstProps<T extends Prisma.BasketFindFirstArgs> = Prisma.SelectSubset<T, Prisma.BasketFindFirstArgs>;
type BasketFindFirstResponse<T extends Prisma.BasketFindFirstArgs> = GetResult<
    Prisma.$BasketPayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type BasketFindUniqueProps<T extends Prisma.BasketFindUniqueArgs> = Prisma.SelectSubset<T, Prisma.BasketFindUniqueArgs>;
type BasketFindUniqueResponse<T extends Prisma.BasketFindUniqueArgs> = GetResult<
    Prisma.$BasketPayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type BasketFindManyProps<T extends Prisma.BasketFindManyArgs> = Prisma.SelectSubset<T, Prisma.BasketFindManyArgs>;
type BasketFindManyResponse<T extends Prisma.BasketFindManyArgs> = GetResult<
    Prisma.$BasketPayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type BasketCountProps<T extends Prisma.BasketCountArgs> = Prisma.SelectSubset<T, Prisma.BasketCountArgs>;
type BasketCountResponse<T extends Prisma.BasketCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.BasketCountAggregateOutputType>
        : number;

// ========== Services ========== //

/**
 * ## Basket Create (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const BasketCreateAction = async <T extends Prisma.BasketCreateArgs>(
    props: BasketCreateProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketCreateResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketCreateAction", "Basket", "create");
    return await BasketService.create(props);
};

/**
 * ## Basket Upsert (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const BasketUpsertAction = async <T extends Prisma.BasketUpsertArgs>(
    props: BasketUpsertProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketUpsertResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketUpsertAction", "Basket", "upsert");
    return await BasketService.upsert(props);
};

/**
 * ## Basket Update (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const BasketUpdateAction = async <T extends Prisma.BasketUpdateArgs>(
    props: BasketUpdateProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketUpdateResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketUpdateAction", "Basket", "update");
    return await BasketService.update(props);
};

/**
 * ## Basket Delete (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const BasketDeleteAction = async <T extends Prisma.BasketDeleteArgs>(
    props: BasketDeleteProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketDeleteResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketDeleteAction", "Basket", "delete");
    return await BasketService.delete(props);
};

/**
 * ## Basket Create Many (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const BasketCreateManyAction = async <T extends Prisma.BasketCreateManyArgs>(
    props: BasketCreateManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketCreateManyResponse> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketCreateManyAction", "Basket", "createMany");
    return await BasketService.createMany(props);
};

/**
 * ## Basket Update Many (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const BasketUpdateManyAction = async <T extends Prisma.BasketUpdateManyArgs>(
    props: BasketUpdateManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketUpdateManyResponse> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketUpdateManyAction", "Basket", "updateMany");
    return await BasketService.updateMany(props);
};

/**
 * ## Basket Delete Many (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const BasketDeleteManyAction = async <T extends Prisma.BasketDeleteManyArgs>(
    props: BasketDeleteManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketDeleteManyResponse> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketDeleteManyAction", "Basket", "deleteMany");
    return await BasketService.deleteMany(props);
};

/**
 * ## Basket Find First (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const BasketFindFirstAction = async <T extends Prisma.BasketFindFirstArgs>(
    props: BasketFindFirstProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketFindFirstResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketFindFirstAction", "Basket", "findFirst");
    return await BasketService.findFirst(props);
};

/**
 * ## Basket Find Unique (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const BasketFindUniqueAction = async <T extends Prisma.BasketFindUniqueArgs>(
    props: BasketFindUniqueProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketFindUniqueResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketFindUniqueAction", "Basket", "findUnique");
    return await BasketService.findUnique(props);
};

/**
 * ## Basket Find Many (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const BasketFindManyAction = async <T extends Prisma.BasketFindManyArgs>(
    props: BasketFindManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketFindManyResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketFindManyAction", "Basket", "findMany");
    return await BasketService.findMany(props);
};

/**
 * ## Basket Count (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const BasketCountAction = async <T extends Prisma.BasketCountArgs>(
    props: BasketCountProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<BasketCountResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "BasketCountAction", "Basket", "count");
    return await BasketService.count(props);
};
